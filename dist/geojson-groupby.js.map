{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "../../../node_modules/multigeojson/index.js",
    "geojson-groupby.js",
    "node_modules/json-groupby/json-groupby.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "//index.js \n(function() { \n\tvar singles = ['Point', 'LineString', 'Polygon'];\n\tvar multies = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n\tfunction explode(g) {\n\t  if( multies.indexOf(g.type) > -1) {\n\t    return g.coordinates.map(function(part) {\n\t      var single = {};\n\t      single.type = g.type.replace('Multi','');\n\t      single.coordinates = part;\n        if(g.crs) single.crs = g.crs;\n\t      return single;\n\t    });  \n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tfunction implode(gs) {\n\t  var sameType = gs.every(function(g) { \n\t    return singles.indexOf(g.type) > -1;\n\t  })\n    var crs = gs[0].crs || 0;\n    var sameCrs = gs.every(function(g) {\n      var gcrs = g.crs || 0;\n      return gcrs == crs;\n    });\n\t  if(sameType && sameCrs) {\n\t    var multi = {};\n\t    multi.type = 'Multi' + gs[0].type;\n\t    multi.coordinates = [];\n      if(crs != 0) multi.crs = crs;\n\t    gs.forEach(function(g) {\n\t      multi.coordinates.push(g.coordinates);\n\t    });\n\t    return multi;\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\tvar multigeojson = {\n\t  explode: explode,\n\t  implode: implode\n\t};\n\tif(typeof module !== 'undefined' && module.exports) {\n\t  module.exports = multigeojson;\n\t} else if(window) {\n\t  window.multigeojson = multigeojson;\n\t}\n})();\n",
    "'use strict';\nvar groupBy = require('json-groupby')\nvar multi = require('multigeojson')\n\nfunction geoGroupBy(features, properties,collect) {\n  var arr = Array.isArray(features) ? features : features.features\n  var collect = collect || []\n  if (collect.indexOf('geometry') < 0) collect.push('geometry')\n  var group = groupBy(arr, properties, collect)\n  return toMultiGeometry(group, {}) \n}\n\nfunction toMultiGeometry(group, merged) {\n  for (var key in group) {\n    if (group[key].geometry) {\n      merged[key] = group[key]\n      merged[key].geometry = multi.implode(group[key].geometry);\n    } else {\n      merged[key] = toMultiGeometry(group[key],{})\n    }\n  }\n  return merged;\n}\nfunction _groupBy() {\n  if (arguments.length < 2) return;\n  var args, features, properties;\n  // get args as array \n  // http://stackoverflow.com/a/15705938/713573\n  args = Array.prototype.slice.call(arguments, 0);\n\n  var features = Array.isArray(args[0]) ? args[0] : args[0].features;\n  var properties = args.slice(1);\n  return properties.reduce(function(group, prop, i, arr) {\n    if (Object.keys(group).length > 0) {\n      for (var key in group) {\n        group[key] = groupBy.apply(null,\n          [group[key]].concat(arr.slice(i))\n        );\n      }\n    } else {\n\t    if (typeof prop === 'string') {\n\t      group = groupByCategory(features, prop);\n\t    } else {\n\t      group = groupByRange(features, prop);\n\t    }\n    }\n    return group;\n  },{});\n}\n\nfunction groupByCategory(arr, prop) {\n  var isPropertyArray = Array.isArray(valueAt(arr[0], prop));\n  if (isPropertyArray) {\n    return arr.reduce(function(group, f) {\n      var tags = valueAt(f, prop);\n      tags.forEach(function(tag) { \n        group[tag] = group[tag] || [];\n        group[tag].push(f);\n      });\n      return group;\n    },{});\n  } else {\n    return arr.reduce(function(group, f) {\n      var tag = valueAt(f, prop);\n      group[tag] = group[tag] || [];\n      group[tag].push(f);\n      return group;\n    },{});\n  }\n}\n\nfunction groupByRange(arr, lookup) {\n  return arr.reduce(function(group, f) {\n    var val, ind, tag;\n    val = valueAt(f, lookup.property);\n    ind = locationOf(val, lookup.intervals);\n    tag = lookup.labels ? lookup.labels[ind] : ind;\n    group[tag] = group[tag] || [];\n    group[tag].push(f);\n    return group;\n  },{});\n}\n\nfunction valueAt(obj,path) {\n  //taken from http://stackoverflow.com/a/6394168/713573\n  function index(prev,cur) { \n    try {\n      return prev[cur]; \n    } catch(e) {\n      throw new Error('Path \"'+path+ '\" is not valid in '+ JSON.stringify(obj)); \n    }\n  }\n  return path.split('.').reduce(index, obj);\n}\n\n// similar to Array.findIndex but more efficient\n// http://stackoverflow.com/q/1344500/713573\nfunction locationOf(element, array, start, end) {\n  start = start || 0;\n  end = end || array.length;\n  var pivot = parseInt(start + (end - start) / 2, 10);\n  if (end-start <= 1 || array[pivot] === element) return pivot;\n  if (array[pivot] < element) {\n    return locationOf(element, array, pivot, end);\n  } else {\n    return locationOf(element, array, start, pivot);\n  }\n}\nmodule.exports = geoGroupBy;\n",
    "'use strict';\n\nfunction groupBy(items, properties, collect) {\n  if (arguments.length < 2) return arr;\n  var groups = _groupBy(items, properties);\n  // collect other properties values in array\n  if (collect && collect.length > 0)\n    groups = collectProperties(groups, collect);\n\n  return groups;\n}\n\nfunction _groupBy(items, properties) {\n  debugger;\n  var group = {};\n \t    if (typeof properties[0] === 'string') {\n \t      group = groupByCategory(items, properties[0]);\n \t    } else {\n \t      group = groupByRange(items, properties[0]);\n \t    }\n      properties = properties.slice(1);\n    if (properties.length > 0) {\n      for (var key in group) {\n        group[key] = _groupBy(group[key], properties);\n      }\n    }\n    return group;\n}\n\nfunction groupByCategory(arr, prop) {\n  var isPropertyArray = Array.isArray(valueAt(arr[0], prop));\n  if (isPropertyArray) {\n    return arr.reduce(function(group, f) {\n      var tags = valueAt(f, prop);\n      tags.forEach(function(tag) { \n        group[tag] = group[tag] || [];\n        group[tag].push(f);\n      });\n      return group;\n    },{});\n  } else {\n    return arr.reduce(function(group, f) {\n      var tag = valueAt(f, prop);\n      group[tag] = group[tag] || [];\n      group[tag].push(f);\n      return group;\n    },{});\n  }\n}\n\nfunction groupByRange(arr, lookup) {\n  return arr.reduce(function(group, f) {\n    var val, ind, tag;\n    val = valueAt(f, lookup.property);\n    ind = locationOf(val, lookup.intervals);\n    if (ind === lookup.intervals.length -1) ind--;\n    tag = lookup.labels ? lookup.labels[ind] : ind;\n    group[tag] = group[tag] || [];\n    group[tag].push(f);\n    return group;\n  },{});\n}\n\n// collect the properties in an array \nfunction collectProperties(groups, properties) { \n  var collection = {};\n  for (var key in groups) {\n    if (Array.isArray(groups[key])) {\n      collection[key] = groups[key].reduce(function(coll, item) {\n        properties.forEach(function(prop) { \n          if (!coll[prop]) coll[prop] = [];\n          coll[prop].push(valueAt(item,prop));\n        })\n        return coll;\n      }, {})\n    } else {\n      collection[key] = collectProperties(groups[key], properties);\n    }\n  }\n  return collection;\n}\n\nfunction valueAt(obj,path) {\n  //taken from http://stackoverflow.com/a/6394168/713573\n  function index(prev,cur, i, arr) { \n    if (prev.hasOwnProperty(cur)) {\n      return prev[cur]; \n    } else {\n      throw new Error(arr.slice(0,i+1).join('.') + ' is not a valid property path'); \n    }\n  }\n  return path.split('.').reduce(index, obj);\n}\n\n// similar to Array.findIndex but more efficient\n// http://stackoverflow.com/q/1344500/713573\nfunction locationOf(element, array, start, end) {\n  start = start || 0;\n  end = end || array.length;\n  var pivot = parseInt(start + (end - start) / 2, 10);\n  if (end-start <= 1 || array[pivot] === element) return pivot;\n  if (array[pivot] < element) {\n    return locationOf(element, array, pivot, end);\n  } else {\n    return locationOf(element, array, start, pivot);\n  }\n}\nmodule.exports = groupBy;\n"
  ]
}